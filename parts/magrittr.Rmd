Can view help by vignette("magrittr") or check out the [online docs](https://www.rdocumentation.org/packages/magrittr/versions/1.5) magrittr is a part of tidyverse

We start with a value, here mtcars (a data.frame). Based on this, we first extract a subset, then we aggregate the information based on the number of cylinders, and then we transform the dataset by adding a variable for kilometers per liter as supplement to miles per gallon. Finally we print the result before assigning it. Note how the code is arranged in the logical order of how you think about the task: `data->transform->aggregate`, which is also the same order as the code will execute. It's like a recipe – easy to read, easy to follow!

`library(magritter)`

```{r magrittr_main}
car_data <- 
  mtcars %>%
  subset(hp > 100) %>%
  aggregate(. ~ cyl, data = ., FUN = . %>% mean %>% round(2)) %>%
  transform(kpl = mpg %>% multiply_by(0.4251)) %>%
  print
```
Note also how “building” a function on the fly for use in aggregate is very simple in magrittr: rather than an actual value as left-hand side in pipeline, just use the placeholder. This is also very useful in R's *apply family of functions.

The combined example shows a few neat features of the pipe (which it is not):

1. By default the left-hand side (LHS) will be piped in as the first argument of the function appearing on the
2. right-hand side (RHS). This is the case in the subset and transform expressions.
3. `%>%` may be used in a nested fashion, e.g. it may appear in expressions within arguments. This is used in the mpg to kpl conversion.
4. When the LHS is needed at a position other than the first, one can use the dot,'.', as placeholder. This is used in the aggregate expression.
5. The dot in e.g. a formula is not confused with a placeholder, which is utilized in the aggregate expression.
6. Whenever only one argument is needed, the LHS, then one can omit the empty parentheses. This is used in the call to print (which also returns its argument). Here, LHS %>% print(), or even LHS %>% print(.) would also work.
7. A pipeline with a dot (.) as LHS will create a unary function. This is used to define the aggregator function.

One feature, which was not utilized above is piping into anonymous functions, or lambdas. This is possible using standard function definitions, e.g.

``` {r m2}
car_data %>%
(function(x) {
  if (nrow(x) > 2) 
    rbind(head(x, 1), tail(x, 1))
  else x
})
```
However, magrittr also allows a short-hand notation:
``` {r m3}
car_data %>%
{ 
  if (nrow(.) > 0)
    rbind(head(., 1), tail(., 1))
  else .
}
```

## Additional Pipe Opperators {.tabset .tabset-pills .tabset-fade}

### Tee %T>%

The “tee” operator, `%T>%` works like `%>%`, except it returns the left-hand side value, and not the result of the right-hand side operation. This is useful when a step in a pipeline is used for its side-effect (printing, plotting, logging, etc.). As an example:

``` {r p1}
rnorm(200) %>%
  matrix(ncol = 2) %T>%
  plot %>% # plot usually does not return anything. 
  colSums
```

### Exposition %$%

The “exposition” pipe operator, `%$%` exposes the names within the left-hand side object to the right-hand side expression. Essentially, it is a short-hand for using the with functions (and the same left-hand side objects are accepted). This operator is handy when functions do not themselves have a data argument, as for example lm and aggregate do. Here are a few examples as illustration:
```{r p2}
iris %>%
  subset(Sepal.Length > mean(Sepal.Length)) %$%
  cor(Sepal.Length, Sepal.Width)

data.frame(z = rnorm(100)) %$% 
  ts.plot(z)
```

### Compound assignment %<>%

Finally, the compound assignment pipe operator `%<>%` can be used as the first pipe in a chain. The effect will be that the result of the pipeline is assigned to the left-hand side object, rather than returning the result as usual. It is essentially shorthand notation for expressions like `foo <- foo %>% bar %>% baz`, which boils down to `foo %<>% bar %>% baz`. Another example is

``` {r p3}
iris$Sepal.Length %<>% sqrt
```

The `%<>%` can be used whenever expr <- ... makes sense, e.g.

* `x %<>% foo %>% bar`
* `x[1:10] %<>% foo %>% bar`
* `x$baz %<>% foo %>% bar`